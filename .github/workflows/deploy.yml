name: Deploy - Production

on:
  workflow_dispatch:
    inputs:
      deploy_only:
        description: "Deploy without building (use latest images)"
        required: false
        default: "false"

permissions:
  contents: read
  packages: read

env:
  REGISTRY: ghcr.io

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: [self-hosted]
    env:
      DATA_FOLDER: ${{ vars.DATA_FOLDER }}
      DOMAIN_NAME: ${{ vars.DOMAIN_NAME }}
      SUBDOMAIN: ${{ vars.SUBDOMAIN }}
      GENERIC_TIMEZONE: ${{ vars.GENERIC_TIMEZONE }}
      SSL_EMAIL: ${{ vars.SSL_EMAIL }}
      REMOTE_PROJECT_PATH: ${{ vars.REMOTE_PROJECT_PATH }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine image tags
        id: images
        run: |
          set -euo pipefail
          REPO=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          echo "next_image=${REGISTRY}/${REPO}-next:latest" >> "$GITHUB_OUTPUT"
          echo "nginx_image=${REGISTRY}/${REPO}-nginx:latest" >> "$GITHUB_OUTPUT"

      - name: Prepare deployment bundle
        run: |
          set -euo pipefail
          
          echo "Current directory: $(pwd)"
          echo "Checking docker directory:"
          ls -la docker/ || echo "docker/ directory not found!"
          
          mkdir -p deploy_bundle
          
          # Verify files exist before copying
          if [ ! -f "docker/docker-compose.yml" ]; then
            echo "ERROR: docker/docker-compose.yml not found!"
            exit 1
          fi
          
          cp docker/docker-compose.yml deploy_bundle/
          
          # Copy caddy_config directory and process Caddyfile
          echo ""
          echo "üîç Checking for Caddyfile source..."
          echo "Looking for: docker/caddy_config/Caddyfile"
          echo "Current directory: $(pwd)"
          echo "Full path would be: $(pwd)/docker/caddy_config/Caddyfile"
          
          if [ -d "docker/caddy_config" ]; then
            echo "‚úÖ Found docker/caddy_config directory"
            ls -la docker/caddy_config/
            mkdir -p deploy_bundle/caddy_config
            
            CADDYFILE_SOURCE="docker/caddy_config/Caddyfile"
            if [ -f "${CADDYFILE_SOURCE}" ]; then
              echo "‚úÖ Found Caddyfile at: ${CADDYFILE_SOURCE}"
              echo "Source file details:"
              ls -la "${CADDYFILE_SOURCE}"
              echo "Source file contents (before processing):"
              cat "${CADDYFILE_SOURCE}"
              
              # Process Caddyfile: replace placeholder with actual domain
              sed "s/n8n\.<domain>\.<suffix>/${SUBDOMAIN}.${DOMAIN_NAME}/g" \
                "${CADDYFILE_SOURCE}" > deploy_bundle/caddy_config/Caddyfile
              echo ""
              echo "‚úÖ Processed Caddyfile with domain: ${SUBDOMAIN}.${DOMAIN_NAME}"
            else
              echo "‚ùå ERROR: Caddyfile not found at ${CADDYFILE_SOURCE}!"
              echo "Contents of docker/caddy_config/:"
              ls -la docker/caddy_config/ || echo "Directory is empty or doesn't exist"
              exit 1
            fi
          else
            echo "‚ùå ERROR: docker/caddy_config directory not found!"
            echo "Contents of docker/:"
            ls -la docker/ || echo "docker/ directory doesn't exist"
            exit 1
          fi
          
          # Generate .env from secrets
          cat > deploy_bundle/.env << EOF
          
          DATA_FOLDER=${DATA_FOLDER}
          DOMAIN_NAME=${DOMAIN_NAME}
          SUBDOMAIN=${SUBDOMAIN}
          GENERIC_TIMEZONE=${GENERIC_TIMEZONE}
          SSL_EMAIL=${SSL_EMAIL}
          EOF
          
          # Verify bundle was created
          echo "Deploy bundle contents:"
          ls -la deploy_bundle/
          if [ -d "deploy_bundle/caddy_config" ]; then
            echo "Caddyfile contents:"
            cat deploy_bundle/caddy_config/Caddyfile
          fi
          echo "Deploy bundle size:"
          du -sh deploy_bundle/

      - name: Copy deployment files to server
        run: |
          set -euo pipefail
          # Create directory structure
          mkdir -p "${REMOTE_PROJECT_PATH}"
          mkdir -p "${DATA_FOLDER}/caddy_config"
          mkdir -p "${DATA_FOLDER}/local_files"
          
          # CRITICAL: Remove any existing Caddyfile (file or directory) at the exact path Docker expects
          CADDYFILE_PATH="${DATA_FOLDER}/caddy_config/Caddyfile"
          if [ -e "${CADDYFILE_PATH}" ]; then
            echo "‚ö†Ô∏è  Removing existing Caddyfile (file or directory) at ${CADDYFILE_PATH}"
            rm -rf "${CADDYFILE_PATH}"
          fi
          
          # Copy all files including hidden ones (like .env) to REMOTE_PROJECT_PATH
          cp -r deploy_bundle/. "${REMOTE_PROJECT_PATH}/"
          
          # CRITICAL: Explicitly copy Caddyfile to the exact path Docker Compose expects
          # Docker Compose mounts from ${DATA_FOLDER}/caddy_config/Caddyfile
          if [ -f "deploy_bundle/caddy_config/Caddyfile" ]; then
            cp deploy_bundle/caddy_config/Caddyfile "${CADDYFILE_PATH}"
            chmod 644 "${CADDYFILE_PATH}"
            echo "‚úÖ Caddyfile copied to exact Docker mount path: ${CADDYFILE_PATH}"
          else
            echo "‚ùå ERROR: Caddyfile not found in deploy_bundle!"
            exit 1
          fi
          
          echo "Files copied to ${REMOTE_PROJECT_PATH}"
          ls -la "${REMOTE_PROJECT_PATH}"
          echo ""
          echo "Verifying Caddyfile at Docker mount path:"
          ls -la "${CADDYFILE_PATH}" || echo "ERROR: Caddyfile not at expected path!"
          echo ""
          echo "Caddyfile contents:"
          cat "${CADDYFILE_PATH}"

      - name: Deploy application
        run: |
          set -euo pipefail
          cd "${REMOTE_PROJECT_PATH}"
          
          # Fix docker-compose.yml to use .env instead of ../.env
          # (since docker-compose.yml and .env are now in the same directory)
          sed -i 's|\.\./\.env|.env|g' docker-compose.yml
          
          # Verify .env file exists
          if [ ! -f ".env" ]; then
            echo "ERROR: .env file not found in ${REMOTE_PROJECT_PATH}"
            ls -la
            exit 1
          fi
          
          # CRITICAL: Final verification of Caddyfile before Docker mount
          CADDYFILE_PATH="${DATA_FOLDER}/caddy_config/Caddyfile"
          echo "üîç Final verification before Docker mount..."
          echo "Checking: ${CADDYFILE_PATH}"
          
          # Check if it exists
          if [ ! -e "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Caddyfile does not exist at ${CADDYFILE_PATH}"
            echo "Directory structure:"
            ls -la "${DATA_FOLDER}/" || echo "DATA_FOLDER does not exist"
            ls -la "${DATA_FOLDER}/caddy_config/" || echo "caddy_config directory does not exist"
            exit 1
          fi
          
          # Check if it's a directory (this would cause the mount error)
          if [ -d "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: ${CADDYFILE_PATH} is a directory, not a file!"
            echo "Removing directory and recreating as file..."
            rm -rf "${CADDYFILE_PATH}"
            # Try to copy from REMOTE_PROJECT_PATH if it exists there
            if [ -f "${REMOTE_PROJECT_PATH}/caddy_config/Caddyfile" ]; then
              cp "${REMOTE_PROJECT_PATH}/caddy_config/Caddyfile" "${CADDYFILE_PATH}"
              chmod 644 "${CADDYFILE_PATH}"
              echo "‚úÖ Recreated Caddyfile from backup location"
            else
              echo "‚ùå ERROR: Cannot recreate Caddyfile - source not found!"
              exit 1
            fi
          fi
          
          # Verify it's a regular file
          if [ ! -f "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: ${CADDYFILE_PATH} exists but is not a regular file!"
            ls -la "${CADDYFILE_PATH}"
            exit 1
          fi
          
          echo "‚úÖ Caddyfile verified: regular file at ${CADDYFILE_PATH}"
          echo "File details:"
          ls -la "${CADDYFILE_PATH}"
          echo ""
          echo "Caddyfile contents:"
          cat "${CADDYFILE_PATH}"
          
          # CRITICAL: Recreate file fresh right before Docker mount to ensure it's definitely a file
          # This handles any edge cases where Docker might see something different
          echo ""
          echo "üîß Recreating Caddyfile fresh right before Docker mount..."
          CADDYFILE_CONTENT=$(cat "${CADDYFILE_PATH}")
          # Remove file completely (including if it's a directory)
          rm -rf "${CADDYFILE_PATH}"
          # Ensure parent directory exists
          mkdir -p "$(dirname "${CADDYFILE_PATH}")"
          # Create file atomically using a temp file then move
          TEMP_FILE="${CADDYFILE_PATH}.tmp"
          printf '%s' "${CADDYFILE_CONTENT}" > "${TEMP_FILE}"
          chmod 644 "${TEMP_FILE}"
          mv "${TEMP_FILE}" "${CADDYFILE_PATH}"
          # Verify the move worked
          if [ ! -f "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Failed to create Caddyfile!"
            exit 1
          fi
          
          # Final verification after recreation
          if [ ! -f "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Failed to recreate Caddyfile!"
            exit 1
          fi
          if [ -d "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Caddyfile is still a directory after recreation!"
            exit 1
          fi
          echo "‚úÖ Caddyfile recreated and verified as regular file"
          ls -la "${CADDYFILE_PATH}"
          
          export DOMAIN="${DOMAIN:-}"
          export SSL_EMAIL="${SSL_EMAIL:-}"
          export DOMAINS="${DOMAINS:-}"
          
          echo "üîÑ Pulling latest images..."
          docker compose pull
          
          echo "üßπ Removing old containers..."
          docker compose down --remove-orphans
          
          # Check if docker compose down caused Caddyfile to become a directory
          echo ""
          echo "üîç Checking Caddyfile after docker compose down..."
          if [ -d "${CADDYFILE_PATH}" ]; then
            echo "‚ö†Ô∏è  WARNING: Caddyfile became a directory after docker compose down!"
            echo "This is the problem! Removing it now..."
            rm -rf "${CADDYFILE_PATH}"
          elif [ -f "${CADDYFILE_PATH}" ]; then
            echo "‚úÖ Caddyfile is still a file after docker compose down"
          else
            echo "‚ö†Ô∏è  Caddyfile doesn't exist after docker compose down (will be recreated)"
          fi
          
          # One more check right before starting containers
          echo ""
          echo "üîç Final check right before Docker mount..."
          if [ ! -f "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Caddyfile disappeared before Docker mount!"
            exit 1
          fi
          if [ -d "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Caddyfile became a directory before Docker mount!"
            exit 1
          fi
          
          # Check for symlinks or other path issues
          echo "Checking path details:"
          ls -la "${CADDYFILE_PATH}"
          readlink -f "${CADDYFILE_PATH}" 2>/dev/null || echo "Not a symlink (or readlink not available)"
          stat "${CADDYFILE_PATH}" 2>/dev/null || echo "Stat not available"
          
          # Verify parent directory
          echo ""
          echo "Checking parent directory:"
          ls -la "${DATA_FOLDER}/caddy_config/"
          
          echo "‚úÖ Caddyfile confirmed as regular file at mount time"
          
          # Verify Docker Compose can resolve the path
          echo ""
          echo "üîç Verifying Docker Compose configuration..."
          echo "DATA_FOLDER value: ${DATA_FOLDER}"
          echo "Expected Caddyfile path: ${DATA_FOLDER}/caddy_config/Caddyfile"
          echo "Actual resolved path: $(readlink -f "${CADDYFILE_PATH}" 2>/dev/null || echo "${CADDYFILE_PATH}")"
          docker compose config 2>&1 | grep -A 10 -B 5 "Caddyfile\|caddy_config" || echo "Caddyfile config not found in output"
          
          # Test if we can access the file the same way Docker will
          echo ""
          echo "üîç Testing file access..."
          test -f "${CADDYFILE_PATH}" && echo "‚úÖ File accessible via test -f" || echo "‚ùå File not accessible"
          cat "${CADDYFILE_PATH}" > /dev/null && echo "‚úÖ File readable" || echo "‚ùå File not readable"
          
          # CRITICAL: Remove and recreate Caddyfile RIGHT before docker compose up
          # docker compose down might leave it as a directory, so we need to fix it
          echo ""
          echo "üîß Final fix: Removing and recreating Caddyfile right before Docker mount..."
          
          # Get the content BEFORE removing the file (try multiple locations)
          CADDYFILE_CONTENT=""
          if [ -f "${CADDYFILE_PATH}" ]; then
            echo "Reading content from current location: ${CADDYFILE_PATH}"
            CADDYFILE_CONTENT=$(cat "${CADDYFILE_PATH}")
          elif [ -f "${REMOTE_PROJECT_PATH}/caddy_config/Caddyfile" ]; then
            echo "Reading content from backup location: ${REMOTE_PROJECT_PATH}/caddy_config/Caddyfile"
            CADDYFILE_CONTENT=$(cat "${REMOTE_PROJECT_PATH}/caddy_config/Caddyfile")
          else
            echo "‚ùå ERROR: Cannot find Caddyfile content to recreate!"
            echo "Checked locations:"
            echo "  - ${CADDYFILE_PATH}"
            echo "  - ${REMOTE_PROJECT_PATH}/caddy_config/Caddyfile"
            exit 1
          fi
          
          if [ -z "${CADDYFILE_CONTENT}" ]; then
            echo "‚ùå ERROR: Caddyfile content is empty!"
            exit 1
          fi
          
          # Now remove the existing file/directory
          if [ -e "${CADDYFILE_PATH}" ]; then
            echo "Removing existing Caddyfile (file or directory)..."
            rm -rf "${CADDYFILE_PATH}"
          fi
          
          # Create file atomically
          TEMP_FILE="${CADDYFILE_PATH}.tmp"
          printf '%s' "${CADDYFILE_CONTENT}" > "${TEMP_FILE}"
          chmod 644 "${TEMP_FILE}"
          mv "${TEMP_FILE}" "${CADDYFILE_PATH}"
          
          # Verify it's definitely a file
          if [ ! -f "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Failed to create Caddyfile as file!"
            ls -la "${CADDYFILE_PATH}" || echo "File doesn't exist"
            exit 1
          fi
          if [ -d "${CADDYFILE_PATH}" ]; then
            echo "‚ùå ERROR: Caddyfile is still a directory after final fix!"
            exit 1
          fi
          
          echo "‚úÖ Caddyfile recreated as file right before Docker mount"
          ls -la "${CADDYFILE_PATH}"
          echo "File type check:"
          test -f "${CADDYFILE_PATH}" && echo "‚úÖ Confirmed: Regular file" || echo "‚ùå Not a regular file"
          test -d "${CADDYFILE_PATH}" && echo "‚ùå ERROR: Still a directory!" || echo "‚úÖ Confirmed: Not a directory"
          
          echo "üöÄ Starting updated containers..."
          docker compose up -d
          
          echo "‚úÖ Deployment completed successfully"
          docker ps --format "table {{.Names}}\t{{.Status}}"
